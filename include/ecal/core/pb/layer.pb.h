// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ecal/core/pb/layer.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_ecal_2fcore_2fpb_2flayer_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_ecal_2fcore_2fpb_2flayer_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3011000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3011004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_ecal_2fcore_2fpb_2flayer_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_ecal_2fcore_2fpb_2flayer_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[6]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_ecal_2fcore_2fpb_2flayer_2eproto;
namespace eCAL {
namespace pb {
class ConnnectionPar;
class ConnnectionParDefaultTypeInternal;
extern ConnnectionParDefaultTypeInternal _ConnnectionPar_default_instance_;
class LayerParInproc;
class LayerParInprocDefaultTypeInternal;
extern LayerParInprocDefaultTypeInternal _LayerParInproc_default_instance_;
class LayerParShm;
class LayerParShmDefaultTypeInternal;
extern LayerParShmDefaultTypeInternal _LayerParShm_default_instance_;
class LayerParTcp;
class LayerParTcpDefaultTypeInternal;
extern LayerParTcpDefaultTypeInternal _LayerParTcp_default_instance_;
class LayerParUdpMC;
class LayerParUdpMCDefaultTypeInternal;
extern LayerParUdpMCDefaultTypeInternal _LayerParUdpMC_default_instance_;
class TLayer;
class TLayerDefaultTypeInternal;
extern TLayerDefaultTypeInternal _TLayer_default_instance_;
}  // namespace pb
}  // namespace eCAL
PROTOBUF_NAMESPACE_OPEN
template<> ::eCAL::pb::ConnnectionPar* Arena::CreateMaybeMessage<::eCAL::pb::ConnnectionPar>(Arena*);
template<> ::eCAL::pb::LayerParInproc* Arena::CreateMaybeMessage<::eCAL::pb::LayerParInproc>(Arena*);
template<> ::eCAL::pb::LayerParShm* Arena::CreateMaybeMessage<::eCAL::pb::LayerParShm>(Arena*);
template<> ::eCAL::pb::LayerParTcp* Arena::CreateMaybeMessage<::eCAL::pb::LayerParTcp>(Arena*);
template<> ::eCAL::pb::LayerParUdpMC* Arena::CreateMaybeMessage<::eCAL::pb::LayerParUdpMC>(Arena*);
template<> ::eCAL::pb::TLayer* Arena::CreateMaybeMessage<::eCAL::pb::TLayer>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace eCAL {
namespace pb {

enum eTLayerType : int {
  tl_none = 0,
  tl_ecal_udp_mc = 1,
  tl_ecal_shm = 4,
  tl_ecal_tcp = 5,
  tl_inproc = 42,
  tl_all = 255,
  eTLayerType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  eTLayerType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool eTLayerType_IsValid(int value);
constexpr eTLayerType eTLayerType_MIN = tl_none;
constexpr eTLayerType eTLayerType_MAX = tl_all;
constexpr int eTLayerType_ARRAYSIZE = eTLayerType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* eTLayerType_descriptor();
template<typename T>
inline const std::string& eTLayerType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, eTLayerType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function eTLayerType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    eTLayerType_descriptor(), enum_t_value);
}
inline bool eTLayerType_Parse(
    const std::string& name, eTLayerType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<eTLayerType>(
    eTLayerType_descriptor(), name, value);
}
// ===================================================================

class LayerParUdpMC :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:eCAL.pb.LayerParUdpMC) */ {
 public:
  LayerParUdpMC();
  virtual ~LayerParUdpMC();

  LayerParUdpMC(const LayerParUdpMC& from);
  LayerParUdpMC(LayerParUdpMC&& from) noexcept
    : LayerParUdpMC() {
    *this = ::std::move(from);
  }

  inline LayerParUdpMC& operator=(const LayerParUdpMC& from) {
    CopyFrom(from);
    return *this;
  }
  inline LayerParUdpMC& operator=(LayerParUdpMC&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LayerParUdpMC& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LayerParUdpMC* internal_default_instance() {
    return reinterpret_cast<const LayerParUdpMC*>(
               &_LayerParUdpMC_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(LayerParUdpMC& a, LayerParUdpMC& b) {
    a.Swap(&b);
  }
  inline void Swap(LayerParUdpMC* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LayerParUdpMC* New() const final {
    return CreateMaybeMessage<LayerParUdpMC>(nullptr);
  }

  LayerParUdpMC* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LayerParUdpMC>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LayerParUdpMC& from);
  void MergeFrom(const LayerParUdpMC& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LayerParUdpMC* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "eCAL.pb.LayerParUdpMC";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ecal_2fcore_2fpb_2flayer_2eproto);
    return ::descriptor_table_ecal_2fcore_2fpb_2flayer_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:eCAL.pb.LayerParUdpMC)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ecal_2fcore_2fpb_2flayer_2eproto;
};
// -------------------------------------------------------------------

class LayerParShm :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:eCAL.pb.LayerParShm) */ {
 public:
  LayerParShm();
  virtual ~LayerParShm();

  LayerParShm(const LayerParShm& from);
  LayerParShm(LayerParShm&& from) noexcept
    : LayerParShm() {
    *this = ::std::move(from);
  }

  inline LayerParShm& operator=(const LayerParShm& from) {
    CopyFrom(from);
    return *this;
  }
  inline LayerParShm& operator=(LayerParShm&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LayerParShm& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LayerParShm* internal_default_instance() {
    return reinterpret_cast<const LayerParShm*>(
               &_LayerParShm_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(LayerParShm& a, LayerParShm& b) {
    a.Swap(&b);
  }
  inline void Swap(LayerParShm* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LayerParShm* New() const final {
    return CreateMaybeMessage<LayerParShm>(nullptr);
  }

  LayerParShm* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LayerParShm>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LayerParShm& from);
  void MergeFrom(const LayerParShm& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LayerParShm* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "eCAL.pb.LayerParShm";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ecal_2fcore_2fpb_2flayer_2eproto);
    return ::descriptor_table_ecal_2fcore_2fpb_2flayer_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMemoryFileListFieldNumber = 1,
  };
  // repeated string memory_file_list = 1;
  int memory_file_list_size() const;
  private:
  int _internal_memory_file_list_size() const;
  public:
  void clear_memory_file_list();
  const std::string& memory_file_list(int index) const;
  std::string* mutable_memory_file_list(int index);
  void set_memory_file_list(int index, const std::string& value);
  void set_memory_file_list(int index, std::string&& value);
  void set_memory_file_list(int index, const char* value);
  void set_memory_file_list(int index, const char* value, size_t size);
  std::string* add_memory_file_list();
  void add_memory_file_list(const std::string& value);
  void add_memory_file_list(std::string&& value);
  void add_memory_file_list(const char* value);
  void add_memory_file_list(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& memory_file_list() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_memory_file_list();
  private:
  const std::string& _internal_memory_file_list(int index) const;
  std::string* _internal_add_memory_file_list();
  public:

  // @@protoc_insertion_point(class_scope:eCAL.pb.LayerParShm)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> memory_file_list_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ecal_2fcore_2fpb_2flayer_2eproto;
};
// -------------------------------------------------------------------

class LayerParInproc :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:eCAL.pb.LayerParInproc) */ {
 public:
  LayerParInproc();
  virtual ~LayerParInproc();

  LayerParInproc(const LayerParInproc& from);
  LayerParInproc(LayerParInproc&& from) noexcept
    : LayerParInproc() {
    *this = ::std::move(from);
  }

  inline LayerParInproc& operator=(const LayerParInproc& from) {
    CopyFrom(from);
    return *this;
  }
  inline LayerParInproc& operator=(LayerParInproc&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LayerParInproc& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LayerParInproc* internal_default_instance() {
    return reinterpret_cast<const LayerParInproc*>(
               &_LayerParInproc_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(LayerParInproc& a, LayerParInproc& b) {
    a.Swap(&b);
  }
  inline void Swap(LayerParInproc* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LayerParInproc* New() const final {
    return CreateMaybeMessage<LayerParInproc>(nullptr);
  }

  LayerParInproc* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LayerParInproc>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LayerParInproc& from);
  void MergeFrom(const LayerParInproc& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LayerParInproc* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "eCAL.pb.LayerParInproc";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ecal_2fcore_2fpb_2flayer_2eproto);
    return ::descriptor_table_ecal_2fcore_2fpb_2flayer_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:eCAL.pb.LayerParInproc)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ecal_2fcore_2fpb_2flayer_2eproto;
};
// -------------------------------------------------------------------

class LayerParTcp :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:eCAL.pb.LayerParTcp) */ {
 public:
  LayerParTcp();
  virtual ~LayerParTcp();

  LayerParTcp(const LayerParTcp& from);
  LayerParTcp(LayerParTcp&& from) noexcept
    : LayerParTcp() {
    *this = ::std::move(from);
  }

  inline LayerParTcp& operator=(const LayerParTcp& from) {
    CopyFrom(from);
    return *this;
  }
  inline LayerParTcp& operator=(LayerParTcp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LayerParTcp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LayerParTcp* internal_default_instance() {
    return reinterpret_cast<const LayerParTcp*>(
               &_LayerParTcp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(LayerParTcp& a, LayerParTcp& b) {
    a.Swap(&b);
  }
  inline void Swap(LayerParTcp* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LayerParTcp* New() const final {
    return CreateMaybeMessage<LayerParTcp>(nullptr);
  }

  LayerParTcp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LayerParTcp>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LayerParTcp& from);
  void MergeFrom(const LayerParTcp& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LayerParTcp* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "eCAL.pb.LayerParTcp";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ecal_2fcore_2fpb_2flayer_2eproto);
    return ::descriptor_table_ecal_2fcore_2fpb_2flayer_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPortFieldNumber = 1,
  };
  // int32 port = 1;
  void clear_port();
  ::PROTOBUF_NAMESPACE_ID::int32 port() const;
  void set_port(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_port() const;
  void _internal_set_port(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:eCAL.pb.LayerParTcp)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::int32 port_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ecal_2fcore_2fpb_2flayer_2eproto;
};
// -------------------------------------------------------------------

class ConnnectionPar :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:eCAL.pb.ConnnectionPar) */ {
 public:
  ConnnectionPar();
  virtual ~ConnnectionPar();

  ConnnectionPar(const ConnnectionPar& from);
  ConnnectionPar(ConnnectionPar&& from) noexcept
    : ConnnectionPar() {
    *this = ::std::move(from);
  }

  inline ConnnectionPar& operator=(const ConnnectionPar& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConnnectionPar& operator=(ConnnectionPar&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ConnnectionPar& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ConnnectionPar* internal_default_instance() {
    return reinterpret_cast<const ConnnectionPar*>(
               &_ConnnectionPar_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ConnnectionPar& a, ConnnectionPar& b) {
    a.Swap(&b);
  }
  inline void Swap(ConnnectionPar* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ConnnectionPar* New() const final {
    return CreateMaybeMessage<ConnnectionPar>(nullptr);
  }

  ConnnectionPar* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ConnnectionPar>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ConnnectionPar& from);
  void MergeFrom(const ConnnectionPar& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConnnectionPar* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "eCAL.pb.ConnnectionPar";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ecal_2fcore_2fpb_2flayer_2eproto);
    return ::descriptor_table_ecal_2fcore_2fpb_2flayer_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLayerParUdpmcFieldNumber = 1,
    kLayerParShmFieldNumber = 2,
    kLayerParInprocFieldNumber = 3,
    kLayerParTcpFieldNumber = 4,
  };
  // .eCAL.pb.LayerParUdpMC layer_par_udpmc = 1;
  bool has_layer_par_udpmc() const;
  private:
  bool _internal_has_layer_par_udpmc() const;
  public:
  void clear_layer_par_udpmc();
  const ::eCAL::pb::LayerParUdpMC& layer_par_udpmc() const;
  ::eCAL::pb::LayerParUdpMC* release_layer_par_udpmc();
  ::eCAL::pb::LayerParUdpMC* mutable_layer_par_udpmc();
  void set_allocated_layer_par_udpmc(::eCAL::pb::LayerParUdpMC* layer_par_udpmc);
  private:
  const ::eCAL::pb::LayerParUdpMC& _internal_layer_par_udpmc() const;
  ::eCAL::pb::LayerParUdpMC* _internal_mutable_layer_par_udpmc();
  public:

  // .eCAL.pb.LayerParShm layer_par_shm = 2;
  bool has_layer_par_shm() const;
  private:
  bool _internal_has_layer_par_shm() const;
  public:
  void clear_layer_par_shm();
  const ::eCAL::pb::LayerParShm& layer_par_shm() const;
  ::eCAL::pb::LayerParShm* release_layer_par_shm();
  ::eCAL::pb::LayerParShm* mutable_layer_par_shm();
  void set_allocated_layer_par_shm(::eCAL::pb::LayerParShm* layer_par_shm);
  private:
  const ::eCAL::pb::LayerParShm& _internal_layer_par_shm() const;
  ::eCAL::pb::LayerParShm* _internal_mutable_layer_par_shm();
  public:

  // .eCAL.pb.LayerParInproc layer_par_inproc = 3;
  bool has_layer_par_inproc() const;
  private:
  bool _internal_has_layer_par_inproc() const;
  public:
  void clear_layer_par_inproc();
  const ::eCAL::pb::LayerParInproc& layer_par_inproc() const;
  ::eCAL::pb::LayerParInproc* release_layer_par_inproc();
  ::eCAL::pb::LayerParInproc* mutable_layer_par_inproc();
  void set_allocated_layer_par_inproc(::eCAL::pb::LayerParInproc* layer_par_inproc);
  private:
  const ::eCAL::pb::LayerParInproc& _internal_layer_par_inproc() const;
  ::eCAL::pb::LayerParInproc* _internal_mutable_layer_par_inproc();
  public:

  // .eCAL.pb.LayerParTcp layer_par_tcp = 4;
  bool has_layer_par_tcp() const;
  private:
  bool _internal_has_layer_par_tcp() const;
  public:
  void clear_layer_par_tcp();
  const ::eCAL::pb::LayerParTcp& layer_par_tcp() const;
  ::eCAL::pb::LayerParTcp* release_layer_par_tcp();
  ::eCAL::pb::LayerParTcp* mutable_layer_par_tcp();
  void set_allocated_layer_par_tcp(::eCAL::pb::LayerParTcp* layer_par_tcp);
  private:
  const ::eCAL::pb::LayerParTcp& _internal_layer_par_tcp() const;
  ::eCAL::pb::LayerParTcp* _internal_mutable_layer_par_tcp();
  public:

  // @@protoc_insertion_point(class_scope:eCAL.pb.ConnnectionPar)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::eCAL::pb::LayerParUdpMC* layer_par_udpmc_;
  ::eCAL::pb::LayerParShm* layer_par_shm_;
  ::eCAL::pb::LayerParInproc* layer_par_inproc_;
  ::eCAL::pb::LayerParTcp* layer_par_tcp_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ecal_2fcore_2fpb_2flayer_2eproto;
};
// -------------------------------------------------------------------

class TLayer :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:eCAL.pb.TLayer) */ {
 public:
  TLayer();
  virtual ~TLayer();

  TLayer(const TLayer& from);
  TLayer(TLayer&& from) noexcept
    : TLayer() {
    *this = ::std::move(from);
  }

  inline TLayer& operator=(const TLayer& from) {
    CopyFrom(from);
    return *this;
  }
  inline TLayer& operator=(TLayer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TLayer& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TLayer* internal_default_instance() {
    return reinterpret_cast<const TLayer*>(
               &_TLayer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(TLayer& a, TLayer& b) {
    a.Swap(&b);
  }
  inline void Swap(TLayer* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TLayer* New() const final {
    return CreateMaybeMessage<TLayer>(nullptr);
  }

  TLayer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TLayer>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TLayer& from);
  void MergeFrom(const TLayer& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TLayer* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "eCAL.pb.TLayer";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ecal_2fcore_2fpb_2flayer_2eproto);
    return ::descriptor_table_ecal_2fcore_2fpb_2flayer_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParShmFieldNumber = 4,
    kParLayerFieldNumber = 5,
    kTypeFieldNumber = 1,
    kVersionFieldNumber = 2,
    kConfirmedFieldNumber = 3,
  };
  // bytes par_shm = 4;
  void clear_par_shm();
  const std::string& par_shm() const;
  void set_par_shm(const std::string& value);
  void set_par_shm(std::string&& value);
  void set_par_shm(const char* value);
  void set_par_shm(const void* value, size_t size);
  std::string* mutable_par_shm();
  std::string* release_par_shm();
  void set_allocated_par_shm(std::string* par_shm);
  private:
  const std::string& _internal_par_shm() const;
  void _internal_set_par_shm(const std::string& value);
  std::string* _internal_mutable_par_shm();
  public:

  // .eCAL.pb.ConnnectionPar par_layer = 5;
  bool has_par_layer() const;
  private:
  bool _internal_has_par_layer() const;
  public:
  void clear_par_layer();
  const ::eCAL::pb::ConnnectionPar& par_layer() const;
  ::eCAL::pb::ConnnectionPar* release_par_layer();
  ::eCAL::pb::ConnnectionPar* mutable_par_layer();
  void set_allocated_par_layer(::eCAL::pb::ConnnectionPar* par_layer);
  private:
  const ::eCAL::pb::ConnnectionPar& _internal_par_layer() const;
  ::eCAL::pb::ConnnectionPar* _internal_mutable_par_layer();
  public:

  // .eCAL.pb.eTLayerType type = 1;
  void clear_type();
  ::eCAL::pb::eTLayerType type() const;
  void set_type(::eCAL::pb::eTLayerType value);
  private:
  ::eCAL::pb::eTLayerType _internal_type() const;
  void _internal_set_type(::eCAL::pb::eTLayerType value);
  public:

  // int32 version = 2;
  void clear_version();
  ::PROTOBUF_NAMESPACE_ID::int32 version() const;
  void set_version(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_version() const;
  void _internal_set_version(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // bool confirmed = 3;
  void clear_confirmed();
  bool confirmed() const;
  void set_confirmed(bool value);
  private:
  bool _internal_confirmed() const;
  void _internal_set_confirmed(bool value);
  public:

  // @@protoc_insertion_point(class_scope:eCAL.pb.TLayer)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr par_shm_;
  ::eCAL::pb::ConnnectionPar* par_layer_;
  int type_;
  ::PROTOBUF_NAMESPACE_ID::int32 version_;
  bool confirmed_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ecal_2fcore_2fpb_2flayer_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// LayerParUdpMC

// -------------------------------------------------------------------

// LayerParShm

// repeated string memory_file_list = 1;
inline int LayerParShm::_internal_memory_file_list_size() const {
  return memory_file_list_.size();
}
inline int LayerParShm::memory_file_list_size() const {
  return _internal_memory_file_list_size();
}
inline void LayerParShm::clear_memory_file_list() {
  memory_file_list_.Clear();
}
inline std::string* LayerParShm::add_memory_file_list() {
  // @@protoc_insertion_point(field_add_mutable:eCAL.pb.LayerParShm.memory_file_list)
  return _internal_add_memory_file_list();
}
inline const std::string& LayerParShm::_internal_memory_file_list(int index) const {
  return memory_file_list_.Get(index);
}
inline const std::string& LayerParShm::memory_file_list(int index) const {
  // @@protoc_insertion_point(field_get:eCAL.pb.LayerParShm.memory_file_list)
  return _internal_memory_file_list(index);
}
inline std::string* LayerParShm::mutable_memory_file_list(int index) {
  // @@protoc_insertion_point(field_mutable:eCAL.pb.LayerParShm.memory_file_list)
  return memory_file_list_.Mutable(index);
}
inline void LayerParShm::set_memory_file_list(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:eCAL.pb.LayerParShm.memory_file_list)
  memory_file_list_.Mutable(index)->assign(value);
}
inline void LayerParShm::set_memory_file_list(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:eCAL.pb.LayerParShm.memory_file_list)
  memory_file_list_.Mutable(index)->assign(std::move(value));
}
inline void LayerParShm::set_memory_file_list(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  memory_file_list_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:eCAL.pb.LayerParShm.memory_file_list)
}
inline void LayerParShm::set_memory_file_list(int index, const char* value, size_t size) {
  memory_file_list_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:eCAL.pb.LayerParShm.memory_file_list)
}
inline std::string* LayerParShm::_internal_add_memory_file_list() {
  return memory_file_list_.Add();
}
inline void LayerParShm::add_memory_file_list(const std::string& value) {
  memory_file_list_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:eCAL.pb.LayerParShm.memory_file_list)
}
inline void LayerParShm::add_memory_file_list(std::string&& value) {
  memory_file_list_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:eCAL.pb.LayerParShm.memory_file_list)
}
inline void LayerParShm::add_memory_file_list(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  memory_file_list_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:eCAL.pb.LayerParShm.memory_file_list)
}
inline void LayerParShm::add_memory_file_list(const char* value, size_t size) {
  memory_file_list_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:eCAL.pb.LayerParShm.memory_file_list)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
LayerParShm::memory_file_list() const {
  // @@protoc_insertion_point(field_list:eCAL.pb.LayerParShm.memory_file_list)
  return memory_file_list_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
LayerParShm::mutable_memory_file_list() {
  // @@protoc_insertion_point(field_mutable_list:eCAL.pb.LayerParShm.memory_file_list)
  return &memory_file_list_;
}

// -------------------------------------------------------------------

// LayerParInproc

// -------------------------------------------------------------------

// LayerParTcp

// int32 port = 1;
inline void LayerParTcp::clear_port() {
  port_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 LayerParTcp::_internal_port() const {
  return port_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 LayerParTcp::port() const {
  // @@protoc_insertion_point(field_get:eCAL.pb.LayerParTcp.port)
  return _internal_port();
}
inline void LayerParTcp::_internal_set_port(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  port_ = value;
}
inline void LayerParTcp::set_port(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:eCAL.pb.LayerParTcp.port)
}

// -------------------------------------------------------------------

// ConnnectionPar

// .eCAL.pb.LayerParUdpMC layer_par_udpmc = 1;
inline bool ConnnectionPar::_internal_has_layer_par_udpmc() const {
  return this != internal_default_instance() && layer_par_udpmc_ != nullptr;
}
inline bool ConnnectionPar::has_layer_par_udpmc() const {
  return _internal_has_layer_par_udpmc();
}
inline void ConnnectionPar::clear_layer_par_udpmc() {
  if (GetArenaNoVirtual() == nullptr && layer_par_udpmc_ != nullptr) {
    delete layer_par_udpmc_;
  }
  layer_par_udpmc_ = nullptr;
}
inline const ::eCAL::pb::LayerParUdpMC& ConnnectionPar::_internal_layer_par_udpmc() const {
  const ::eCAL::pb::LayerParUdpMC* p = layer_par_udpmc_;
  return p != nullptr ? *p : *reinterpret_cast<const ::eCAL::pb::LayerParUdpMC*>(
      &::eCAL::pb::_LayerParUdpMC_default_instance_);
}
inline const ::eCAL::pb::LayerParUdpMC& ConnnectionPar::layer_par_udpmc() const {
  // @@protoc_insertion_point(field_get:eCAL.pb.ConnnectionPar.layer_par_udpmc)
  return _internal_layer_par_udpmc();
}
inline ::eCAL::pb::LayerParUdpMC* ConnnectionPar::release_layer_par_udpmc() {
  // @@protoc_insertion_point(field_release:eCAL.pb.ConnnectionPar.layer_par_udpmc)
  
  ::eCAL::pb::LayerParUdpMC* temp = layer_par_udpmc_;
  layer_par_udpmc_ = nullptr;
  return temp;
}
inline ::eCAL::pb::LayerParUdpMC* ConnnectionPar::_internal_mutable_layer_par_udpmc() {
  
  if (layer_par_udpmc_ == nullptr) {
    auto* p = CreateMaybeMessage<::eCAL::pb::LayerParUdpMC>(GetArenaNoVirtual());
    layer_par_udpmc_ = p;
  }
  return layer_par_udpmc_;
}
inline ::eCAL::pb::LayerParUdpMC* ConnnectionPar::mutable_layer_par_udpmc() {
  // @@protoc_insertion_point(field_mutable:eCAL.pb.ConnnectionPar.layer_par_udpmc)
  return _internal_mutable_layer_par_udpmc();
}
inline void ConnnectionPar::set_allocated_layer_par_udpmc(::eCAL::pb::LayerParUdpMC* layer_par_udpmc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete layer_par_udpmc_;
  }
  if (layer_par_udpmc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      layer_par_udpmc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, layer_par_udpmc, submessage_arena);
    }
    
  } else {
    
  }
  layer_par_udpmc_ = layer_par_udpmc;
  // @@protoc_insertion_point(field_set_allocated:eCAL.pb.ConnnectionPar.layer_par_udpmc)
}

// .eCAL.pb.LayerParShm layer_par_shm = 2;
inline bool ConnnectionPar::_internal_has_layer_par_shm() const {
  return this != internal_default_instance() && layer_par_shm_ != nullptr;
}
inline bool ConnnectionPar::has_layer_par_shm() const {
  return _internal_has_layer_par_shm();
}
inline void ConnnectionPar::clear_layer_par_shm() {
  if (GetArenaNoVirtual() == nullptr && layer_par_shm_ != nullptr) {
    delete layer_par_shm_;
  }
  layer_par_shm_ = nullptr;
}
inline const ::eCAL::pb::LayerParShm& ConnnectionPar::_internal_layer_par_shm() const {
  const ::eCAL::pb::LayerParShm* p = layer_par_shm_;
  return p != nullptr ? *p : *reinterpret_cast<const ::eCAL::pb::LayerParShm*>(
      &::eCAL::pb::_LayerParShm_default_instance_);
}
inline const ::eCAL::pb::LayerParShm& ConnnectionPar::layer_par_shm() const {
  // @@protoc_insertion_point(field_get:eCAL.pb.ConnnectionPar.layer_par_shm)
  return _internal_layer_par_shm();
}
inline ::eCAL::pb::LayerParShm* ConnnectionPar::release_layer_par_shm() {
  // @@protoc_insertion_point(field_release:eCAL.pb.ConnnectionPar.layer_par_shm)
  
  ::eCAL::pb::LayerParShm* temp = layer_par_shm_;
  layer_par_shm_ = nullptr;
  return temp;
}
inline ::eCAL::pb::LayerParShm* ConnnectionPar::_internal_mutable_layer_par_shm() {
  
  if (layer_par_shm_ == nullptr) {
    auto* p = CreateMaybeMessage<::eCAL::pb::LayerParShm>(GetArenaNoVirtual());
    layer_par_shm_ = p;
  }
  return layer_par_shm_;
}
inline ::eCAL::pb::LayerParShm* ConnnectionPar::mutable_layer_par_shm() {
  // @@protoc_insertion_point(field_mutable:eCAL.pb.ConnnectionPar.layer_par_shm)
  return _internal_mutable_layer_par_shm();
}
inline void ConnnectionPar::set_allocated_layer_par_shm(::eCAL::pb::LayerParShm* layer_par_shm) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete layer_par_shm_;
  }
  if (layer_par_shm) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      layer_par_shm = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, layer_par_shm, submessage_arena);
    }
    
  } else {
    
  }
  layer_par_shm_ = layer_par_shm;
  // @@protoc_insertion_point(field_set_allocated:eCAL.pb.ConnnectionPar.layer_par_shm)
}

// .eCAL.pb.LayerParInproc layer_par_inproc = 3;
inline bool ConnnectionPar::_internal_has_layer_par_inproc() const {
  return this != internal_default_instance() && layer_par_inproc_ != nullptr;
}
inline bool ConnnectionPar::has_layer_par_inproc() const {
  return _internal_has_layer_par_inproc();
}
inline void ConnnectionPar::clear_layer_par_inproc() {
  if (GetArenaNoVirtual() == nullptr && layer_par_inproc_ != nullptr) {
    delete layer_par_inproc_;
  }
  layer_par_inproc_ = nullptr;
}
inline const ::eCAL::pb::LayerParInproc& ConnnectionPar::_internal_layer_par_inproc() const {
  const ::eCAL::pb::LayerParInproc* p = layer_par_inproc_;
  return p != nullptr ? *p : *reinterpret_cast<const ::eCAL::pb::LayerParInproc*>(
      &::eCAL::pb::_LayerParInproc_default_instance_);
}
inline const ::eCAL::pb::LayerParInproc& ConnnectionPar::layer_par_inproc() const {
  // @@protoc_insertion_point(field_get:eCAL.pb.ConnnectionPar.layer_par_inproc)
  return _internal_layer_par_inproc();
}
inline ::eCAL::pb::LayerParInproc* ConnnectionPar::release_layer_par_inproc() {
  // @@protoc_insertion_point(field_release:eCAL.pb.ConnnectionPar.layer_par_inproc)
  
  ::eCAL::pb::LayerParInproc* temp = layer_par_inproc_;
  layer_par_inproc_ = nullptr;
  return temp;
}
inline ::eCAL::pb::LayerParInproc* ConnnectionPar::_internal_mutable_layer_par_inproc() {
  
  if (layer_par_inproc_ == nullptr) {
    auto* p = CreateMaybeMessage<::eCAL::pb::LayerParInproc>(GetArenaNoVirtual());
    layer_par_inproc_ = p;
  }
  return layer_par_inproc_;
}
inline ::eCAL::pb::LayerParInproc* ConnnectionPar::mutable_layer_par_inproc() {
  // @@protoc_insertion_point(field_mutable:eCAL.pb.ConnnectionPar.layer_par_inproc)
  return _internal_mutable_layer_par_inproc();
}
inline void ConnnectionPar::set_allocated_layer_par_inproc(::eCAL::pb::LayerParInproc* layer_par_inproc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete layer_par_inproc_;
  }
  if (layer_par_inproc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      layer_par_inproc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, layer_par_inproc, submessage_arena);
    }
    
  } else {
    
  }
  layer_par_inproc_ = layer_par_inproc;
  // @@protoc_insertion_point(field_set_allocated:eCAL.pb.ConnnectionPar.layer_par_inproc)
}

// .eCAL.pb.LayerParTcp layer_par_tcp = 4;
inline bool ConnnectionPar::_internal_has_layer_par_tcp() const {
  return this != internal_default_instance() && layer_par_tcp_ != nullptr;
}
inline bool ConnnectionPar::has_layer_par_tcp() const {
  return _internal_has_layer_par_tcp();
}
inline void ConnnectionPar::clear_layer_par_tcp() {
  if (GetArenaNoVirtual() == nullptr && layer_par_tcp_ != nullptr) {
    delete layer_par_tcp_;
  }
  layer_par_tcp_ = nullptr;
}
inline const ::eCAL::pb::LayerParTcp& ConnnectionPar::_internal_layer_par_tcp() const {
  const ::eCAL::pb::LayerParTcp* p = layer_par_tcp_;
  return p != nullptr ? *p : *reinterpret_cast<const ::eCAL::pb::LayerParTcp*>(
      &::eCAL::pb::_LayerParTcp_default_instance_);
}
inline const ::eCAL::pb::LayerParTcp& ConnnectionPar::layer_par_tcp() const {
  // @@protoc_insertion_point(field_get:eCAL.pb.ConnnectionPar.layer_par_tcp)
  return _internal_layer_par_tcp();
}
inline ::eCAL::pb::LayerParTcp* ConnnectionPar::release_layer_par_tcp() {
  // @@protoc_insertion_point(field_release:eCAL.pb.ConnnectionPar.layer_par_tcp)
  
  ::eCAL::pb::LayerParTcp* temp = layer_par_tcp_;
  layer_par_tcp_ = nullptr;
  return temp;
}
inline ::eCAL::pb::LayerParTcp* ConnnectionPar::_internal_mutable_layer_par_tcp() {
  
  if (layer_par_tcp_ == nullptr) {
    auto* p = CreateMaybeMessage<::eCAL::pb::LayerParTcp>(GetArenaNoVirtual());
    layer_par_tcp_ = p;
  }
  return layer_par_tcp_;
}
inline ::eCAL::pb::LayerParTcp* ConnnectionPar::mutable_layer_par_tcp() {
  // @@protoc_insertion_point(field_mutable:eCAL.pb.ConnnectionPar.layer_par_tcp)
  return _internal_mutable_layer_par_tcp();
}
inline void ConnnectionPar::set_allocated_layer_par_tcp(::eCAL::pb::LayerParTcp* layer_par_tcp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete layer_par_tcp_;
  }
  if (layer_par_tcp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      layer_par_tcp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, layer_par_tcp, submessage_arena);
    }
    
  } else {
    
  }
  layer_par_tcp_ = layer_par_tcp;
  // @@protoc_insertion_point(field_set_allocated:eCAL.pb.ConnnectionPar.layer_par_tcp)
}

// -------------------------------------------------------------------

// TLayer

// .eCAL.pb.eTLayerType type = 1;
inline void TLayer::clear_type() {
  type_ = 0;
}
inline ::eCAL::pb::eTLayerType TLayer::_internal_type() const {
  return static_cast< ::eCAL::pb::eTLayerType >(type_);
}
inline ::eCAL::pb::eTLayerType TLayer::type() const {
  // @@protoc_insertion_point(field_get:eCAL.pb.TLayer.type)
  return _internal_type();
}
inline void TLayer::_internal_set_type(::eCAL::pb::eTLayerType value) {
  
  type_ = value;
}
inline void TLayer::set_type(::eCAL::pb::eTLayerType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:eCAL.pb.TLayer.type)
}

// int32 version = 2;
inline void TLayer::clear_version() {
  version_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TLayer::_internal_version() const {
  return version_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TLayer::version() const {
  // @@protoc_insertion_point(field_get:eCAL.pb.TLayer.version)
  return _internal_version();
}
inline void TLayer::_internal_set_version(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  version_ = value;
}
inline void TLayer::set_version(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:eCAL.pb.TLayer.version)
}

// bool confirmed = 3;
inline void TLayer::clear_confirmed() {
  confirmed_ = false;
}
inline bool TLayer::_internal_confirmed() const {
  return confirmed_;
}
inline bool TLayer::confirmed() const {
  // @@protoc_insertion_point(field_get:eCAL.pb.TLayer.confirmed)
  return _internal_confirmed();
}
inline void TLayer::_internal_set_confirmed(bool value) {
  
  confirmed_ = value;
}
inline void TLayer::set_confirmed(bool value) {
  _internal_set_confirmed(value);
  // @@protoc_insertion_point(field_set:eCAL.pb.TLayer.confirmed)
}

// bytes par_shm = 4;
inline void TLayer::clear_par_shm() {
  par_shm_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& TLayer::par_shm() const {
  // @@protoc_insertion_point(field_get:eCAL.pb.TLayer.par_shm)
  return _internal_par_shm();
}
inline void TLayer::set_par_shm(const std::string& value) {
  _internal_set_par_shm(value);
  // @@protoc_insertion_point(field_set:eCAL.pb.TLayer.par_shm)
}
inline std::string* TLayer::mutable_par_shm() {
  // @@protoc_insertion_point(field_mutable:eCAL.pb.TLayer.par_shm)
  return _internal_mutable_par_shm();
}
inline const std::string& TLayer::_internal_par_shm() const {
  return par_shm_.GetNoArena();
}
inline void TLayer::_internal_set_par_shm(const std::string& value) {
  
  par_shm_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void TLayer::set_par_shm(std::string&& value) {
  
  par_shm_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:eCAL.pb.TLayer.par_shm)
}
inline void TLayer::set_par_shm(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  par_shm_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:eCAL.pb.TLayer.par_shm)
}
inline void TLayer::set_par_shm(const void* value, size_t size) {
  
  par_shm_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:eCAL.pb.TLayer.par_shm)
}
inline std::string* TLayer::_internal_mutable_par_shm() {
  
  return par_shm_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* TLayer::release_par_shm() {
  // @@protoc_insertion_point(field_release:eCAL.pb.TLayer.par_shm)
  
  return par_shm_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void TLayer::set_allocated_par_shm(std::string* par_shm) {
  if (par_shm != nullptr) {
    
  } else {
    
  }
  par_shm_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), par_shm);
  // @@protoc_insertion_point(field_set_allocated:eCAL.pb.TLayer.par_shm)
}

// .eCAL.pb.ConnnectionPar par_layer = 5;
inline bool TLayer::_internal_has_par_layer() const {
  return this != internal_default_instance() && par_layer_ != nullptr;
}
inline bool TLayer::has_par_layer() const {
  return _internal_has_par_layer();
}
inline void TLayer::clear_par_layer() {
  if (GetArenaNoVirtual() == nullptr && par_layer_ != nullptr) {
    delete par_layer_;
  }
  par_layer_ = nullptr;
}
inline const ::eCAL::pb::ConnnectionPar& TLayer::_internal_par_layer() const {
  const ::eCAL::pb::ConnnectionPar* p = par_layer_;
  return p != nullptr ? *p : *reinterpret_cast<const ::eCAL::pb::ConnnectionPar*>(
      &::eCAL::pb::_ConnnectionPar_default_instance_);
}
inline const ::eCAL::pb::ConnnectionPar& TLayer::par_layer() const {
  // @@protoc_insertion_point(field_get:eCAL.pb.TLayer.par_layer)
  return _internal_par_layer();
}
inline ::eCAL::pb::ConnnectionPar* TLayer::release_par_layer() {
  // @@protoc_insertion_point(field_release:eCAL.pb.TLayer.par_layer)
  
  ::eCAL::pb::ConnnectionPar* temp = par_layer_;
  par_layer_ = nullptr;
  return temp;
}
inline ::eCAL::pb::ConnnectionPar* TLayer::_internal_mutable_par_layer() {
  
  if (par_layer_ == nullptr) {
    auto* p = CreateMaybeMessage<::eCAL::pb::ConnnectionPar>(GetArenaNoVirtual());
    par_layer_ = p;
  }
  return par_layer_;
}
inline ::eCAL::pb::ConnnectionPar* TLayer::mutable_par_layer() {
  // @@protoc_insertion_point(field_mutable:eCAL.pb.TLayer.par_layer)
  return _internal_mutable_par_layer();
}
inline void TLayer::set_allocated_par_layer(::eCAL::pb::ConnnectionPar* par_layer) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete par_layer_;
  }
  if (par_layer) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      par_layer = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, par_layer, submessage_arena);
    }
    
  } else {
    
  }
  par_layer_ = par_layer;
  // @@protoc_insertion_point(field_set_allocated:eCAL.pb.TLayer.par_layer)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace pb
}  // namespace eCAL

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::eCAL::pb::eTLayerType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::eCAL::pb::eTLayerType>() {
  return ::eCAL::pb::eTLayerType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_ecal_2fcore_2fpb_2flayer_2eproto
